# 多线程

### 创建线程

#### 方式一 Thread

通过继承Thread类来创建并启动多线程的步骤如下：

1. 定义一个类，让其继承Thread类
2. 重写Thread类中的的run方法（该run方法的方法体就代表了线程需要完成的任务。因此把 run 方法称之为线程执行体）。
3. 创建Thread子类的实例，即创建了线程对象。
4. 调用线程对象的start()方法来启动该线程。

```java
public class MyThread extends Thread {
	/**
	* run方法封装的就是要被线程执行的任务，因此我们也将其称之为线程执行体
	*/
	@Override
	public void run() {
		for(int x = 0 ; x < 100 ; x++) {
			System.out.println(x);
		}
	}
}
```



start 与 run 方法区别 : 

1. 调用start方法jvm会开启一个线程(新的路径)去执行run方法中代码 ， 调用run方法就是把 run 方法当做普通方法去执行，jvm不会去开启一个线程来执行
2. start方法只能调用一次，run方法可以调用多次



#### 方式二 Runnable

实现Runnable接口来创建并启动多线程的步骤如下：

1).定义Runnable接口的实现类，并重写该接口的run方法

2). 创建Runnable实现类的实例

3). 创建Thread对象，然后将第二步创建实例作为参数传递过来

4). 调用start方法启动



线程线程类代码: 

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for(int x = 0 ; x < 100 ; x++) {
        	System.out.println(x);
        }
    }
}
```

测试类 :

```java
public class RunnableDemo01 {
    public static void main(String[] args) {
        // 创建Runnable的实例对象
        MyRunnable myRunnable = new MyRunnable() ;
        
        // 创建Thread对象，然后将第二步创建实例作为参数传递过来
        Thread t1 = new Thread(myRunnable) ;
        // 创建线程对象
        Thread t2 = new Thread(myRunnable) ;
        
        // 调用start方法启动线程
        t1.start();
        t2.start();
    }
}
```



#### 方式三 Callable和FutureTask

从java5开始，Java提供了Callable接口，该接口怎么看都像是Runnable接口的增强版，Callable接口提供了一个call，但是call方法比run方法功能更加强大，call方法可以有返回值。

但是我们并不能直接将Callable对象作为Thread的构造方法的参数进行传递，因为Callable不是Runnable。但是 java5 以后提供了一个FutureTask，查看其继承体系图，我们可以看到FutureTask是Runnabla的子类。

![1572427762522](assets/1572427762522.png) 

那么我们就可以去创建FutureTask对象，将其作为Thread的构造方法参数进行传递。并且FutureTask对象在创建的时候我们可以为其传递一个Callable的对象。
具体的实现步骤如下：

1). 创建一个类实现Callable接口，并重写call方法

2). 创建Callable实现类的对象

3). 创建FutureTask对象，把第二步创建的对象作为参数进行传递

4). 创建Thread对象，把第三步创建的FutureTask对象作为传递进行传递

5). 调用start方法启动线程

6). 调用FutureTask对象的get方法获取线程执行结果



线程类代码:

```java
public class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int result = 0 ;
        for(int x = 0 ; x <= 100 ; x++) {
        	result += x ;
        }
        return result;
    }
}
```



测试类代码:

```java
public class CallableDemo1 {
    public static void main(String[] args) throws Exception{
        // 创建Callable实现类的对象
        MyCallable myCallable = new MyCallable() ;
        // 创建FutureTask对象，把第二步创建的对象作为参数进行传递
        FutureTask<Integer> futureTask = new FutureTask<Integer>(myCallable) ;

        Thread thread = new Thread(futureTask , "线程一") ;
        // 调用start方法启动线程
        thread.start();
        // 调用FutureTask对象的get方法获取线程执行结果
        Integer integer = futureTask.get();
        System.out.println(integer);
    }
}
```



### 线程休眠

概述：就是让当前的正在执行的线程暂停一段时间，让线程处于阻塞状态(暂停执行的状态)。
1). 使用Thread类中的如下方法设置线程的休眠实现 :

```
public static void sleep(long time) // 让线程休眠指定的时间，单位为毫秒
```



2). JDK1.5提供的枚举类：TimeUnit来设置线程的休眠时间,使用格式: TimeUnit.时间单位.sleep(时间值)；

```
TimeUnit.DAYS.sleep(1); // 休眠1天
TimeUnit.HOURS.sleep(1); // 休眠1小时
TimeUnit.MINUTES.sleep(1); // 休眠1分钟
TimeUnit.SECONDS.sleep(1); // 休眠1秒
```



### 线程优先级

#### 线程调度模型

概述：线程的调度指的是系统为线程分配CPU使用权的过程。
调度模型：
1). 分时调度：指让所有的线程轮流获得cpu的使用权,并且平均分配每个线程占用的CPU的时间片这个也比较好理解。
2). 抢占式调度模型：是指优先让优先级高的线程优先占用CPU的执行权，如果线程优先级相同，那么就随机选择一个线程，使其占用CPU的执行权。

我们java虚拟机采用的就是抢占式调度模型。







#### 优先级

我们可以通过如下方法对线程的优先级进行获取和设置操作：

```java
public final void setPriority(int newPriority) // 设置线程的优先级
public final int getPriority() // 获取线程的优先级
```

默认的线程的优先级是： 5

![1572428629063](assets/1572428629063.png) 

通过源码我们查看到可以设置的线程优先级：  1 <= newPriority <= 10



注：我们通过设置线程的优先级来 "建议" jvm优先执行某一个线程，但是jvm不一定采纳。因此我们不要企图使用线程的优先级来绑定某一些业务操作。

代码实现: 

```java
public class ThreadDemo1 {
    public static void main(String[] args) {
        // 创建MyThread线程对象
        MyThread t1 = new MyThread();
        t1.setName("线程一");
        
        // 创建MyThread线程对象
        MyThread t2 = new MyThread();
        t2.setName("线程二");
        
        /**
        * 现在我们的在程序中并没有给这两个线程去设置线程的优先级，那么系统会给线程提供一个默认的优先级
        * 那么这个两个线程的优先级就是相同的，因此系统会随机选择一个线程去执行；
        *
        * 我们可以调用
        *
        * public final void setPriority(int newPriority) // 设置线程的优先级
        * public final int getPriority() // 获取线程的优先级
        *
        * 这个两个方法去设置或者获取线程的优先级
        *
        */
        System.out.println("t1线程的优先级------>>>>" +t1.getPriority());
        System.out.println("t2线程的优先级------>>>>" +t2.getPriority());
        /**
        * public final void setPriority(int newPriority)
        // 设置线程的优先级
        *
        * 设置线程的优先级需要一个int的类型的值，这个int类型的值是一个没有范围的值吗？看源码得结果
        * 1 <= newPriority <= 10
        */
        t1.setPriority(10);
        t2.setPriority(1);
        
        /**
        * 注：我们通过设置线程的优先级来"建议"jvm优先执行某一个线程，
        但是jvm不一定采纳。因此我们不要企图使用线程的优先级来绑定某一些业务操作。
        * 此方法了解
        */
        // 启动线程
        t1.start();
        t2.start();
    }
}
```



### 后台线程

概述： 有一种线程是在后台运行的，它的任务就是为其他的线程提供服务，这种线程被称之为"后台线程"，又被称之为"守护线程"。JVM的垃圾回收线程就是典型的后台线程。
后台线程的特征：如果所有的前台线程都死亡，后台线程会自动死亡。当整个JVM中只存在后台线程，那么程序就没有运行的必要了，整个JVM就退出了。



#### 查看线程

当我们启动了一个java进程，那么在该进程中会存在很多个后台的线程，我们可以使用jdk自带的工具：jstack去查看一个进程中所对应的线程。

jstack的使用步骤: 

```js
先使用jps命令查看现在系统中所存在的java进程。
C:\Users\Administrator>jps

在使用jstack去查询指定进程中所对应的线程
jstack -l 37204(进程id)
```



线程类 :

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        for(int x = 0 ; x < 100 ; x++) {
       	 	System.out.println(Thread.currentThread().getName() + "----" + x );
        }
    }
}
```

测试类：

```java
public class ThreadDemo1 {
    public static void main(String[] args) {
        System.out.println("程序启动了.............");
        try {
            TimeUnit.HOURS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



#### 设置守护线程

我们可以调用如下方法，将某一个线程设置为守护线程

```
public final void setDaemon(boolean on) ;// 将某一个线程设置为后台线程
```

代码实现：

```java
public class ThreadDemo2 {
	
    public static void main(String[] args) {
        // 开启两个线程
        MyThread t1 = new MyThread();
        t1.setName("关羽");
        
        MyThread t2 = new MyThread();
        t2.setName("张飞");
        
        // 将关羽线程设置为守护线程
        t1.setDaemon(true);
        t2.setDaemon(true);
        
        // 启动线程
        t1.start();
        t2.start();
        
        // 在主线程中编写代码
        Thread.currentThread().setName("刘备");
        for(int x = 0 ; x < 10 ; x++) {
        	System.out.println(Thread.currentThread().getName() + "-----" + x);
        }
        /**
        * 当我们的程序启动起来以后，我们自己主动使用的线程应该是3个，其中主线程不是守护线程，t1和t2是守护线程，当主线程执行完毕以后那么剩下的线程都是守护线程了jvm就会终止
        */
    }
}
```

注：
1. 前台线程死亡后，JVM会通知后台线程死亡，但从它接收到指令到做出响应，需要一定时间。
2. 要将某一个线程设置为后台线程，必须在该线程启动之前设置。





### 线程生命周期

概述：线程从创建到死亡的整个过程。
当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过新建(new) , 就绪(Runnable) , 运行(Running) ,阻塞(Blocked) 和死亡(Dead)5种状态。
cpu需要在多个线程间进行切换，因此线程的状态也会多次的在运行和阻塞之间进行切换。

![1572430109924](assets/1572430109924.png) 

1). 新建状态：当程序使用new关键字创建了一个线程之后，该线程就处于新建状态 。
2). 就绪状态：当调用了start()方法以后，线程就进入到了就绪状态，此时线程并没有运行，仅仅表示可以运行了 。
3). 运行状态：线程获取到了CPU的执行权，开始执行了 。
4). 阻塞状态：调用了sleep()或者 join() 方法就让线程处于阻塞状态
5). 死亡状态：run方法执行完毕，获取调用了stop方法或者线程抛出了一个未捕获的Exception或者Error







# 线程池

## 概念

在系统启动时，会创建一些线程，当程序需要使用线程，则从线程池中获取线程，获取到线程后进行业务操作，操作完成后再将线程归还到i线程池，等待执行下一次任务。

## 创建线程的三种方式

方式一:

```java
extends Thread

public class FirstThread extends Thread{
    @Override
    public void run() {
        while (true){
            try{
                Thread.sleep(1000);
            }catch (Exception e){
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread()+"执行了.....");
        }
    }
}

启动：
FirstThread firstThread = new FirstThread();
firstThread.start();
```

方式二:

```java
implements Runnable

public class SecondThread implements Runnable {

    public void run() {
        while (true){
            try{
                Thread.sleep(1000);
            }catch (Exception e){
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread()+"执行了.....");
        }
    }
}
启动:
SecondThread secondThread = new SecondThread();
Thread t = new Thread(secondThread);
t.start();
```

方式三:

```java
implements Callable

public class ThridThread implements Callable{
    public Object call() throws Exception {
        int i = 100;
        while (i>0){
            try{
                Thread.sleep(1000);
            }catch (Exception e){
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread()+"执行了.....");
            i--;
        }
        return null;
    }
}
启动(需要借助线程池来启动):
ThridThread thridThread = new ThridThread();
Future future = Executors.newSingleThreadExecutor().submit(thridThread);
Object obj = future.get();
System.out.println(obj);
```

implements Ruunable和 Callable之间的区别

Runnable:

​	重写的是run方法，方法中没有返回值，不能向往抛出异常，可以独立启动

Callable

​	重写的是call方法，方法有返回值，可以向往抛出异常，需要借助线程池才能启动

## 使用线程池的原因

如果不使用线程池，则在多线程的运行环境中，线程会被不断的启动和关闭，成本非常高，会过度消耗系统资源从而导致系统资源的崩溃。线程池就可以很好的达到线程的重复利用，减少线程的创建和销毁成本，以达到解决上述问题的目的。

## 线程池的创建

核心类:ThreadPoolExecutor

打开该类可以看到一个有七个参数的构造函数

```java
10个任务 -3 = 7-2=5-2=3
public ThreadPoolExecutor(int corePoolSize,  3
                              int maximumPoolSize, 5
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,  2
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
```

参数解释:

corePoolSize: 指定核心线程池大小

maximumPoolSize:线程池中运行的最大线程数

keepAliveTime:当线程池中的线程数大于线程池的核心数量后，多出来的线程在线程池中的存活的空闲时间，销毁之前会一直等待新任务

TimeUnit:为上述时间指定时间单位

BlockingQueue:阻塞队列，用来存储还未执行的线程任务

​	接口的实现类：

​		ArrayBlockingQueue:数组阻塞队列

​		LinkedBlockingQueue:链表阻塞队列

​		DelayQueue：延迟阻塞队列

​		PriorityBlockingQueue:具有优先级的阻塞队列

​		SynchronousQueue:同步阻塞队列

ThreadFactory

​		创建项目的工厂类

​			Executors.defaultThreadFactory()

RejectedExecutionHandler:拒绝策略

​	当线程总数超过maximumPoolSize+BlockingQueue中的数量时的处理方式

​		**AbortPolicy** 默认，如果线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常

​		**DiscardPolicy**  如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常

​		**DiscardOldestPolicy** 如果队列满了，会将最早进入队列的任务删掉腾出空间，再尝试加入队列

​		**CallerRunsPolicy**  如果队列满了，多出的任务会被主线程执行

​		**自定义**



## 常用线程池的创建

工具类Executors 

```java
Executors.newSingleThreadExecutor();   --创建只包含一个线程的线程池
```

```java
Executors.newFixedThreadPool(int nThreads); --创建包含指定大小个数线程的线程池
```

```java
Executors.newCachedThreadPool(); --创建一个可缓存的线程池，有多少任务会创建多少个线程
```

```java
Executors.newScheduledThreadPool (int nThreads)  --创建一个定长线程池，支持定时及周期性任务执行
```





## 多线程应用场景

在消息中间件中的消息如果过多，可以使用线程池来使用多个线程对消息进行消费，加速消息的消费，这样既可以用到多线程也可以是一种解决消息中间件的消息阻塞问题。





 