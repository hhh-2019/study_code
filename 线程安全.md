# 1. 线程安全

## 1.1 安全问题演示

```java
public class TicketDemo implements Runnable{

    private static int x = 100; // 票的数量

    @Override
    public void run() {
        while (true) {
            saleTicket();
        }
    }

    public void saleTicket() {
        if (x > 0) {
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + "正在出售第 " + x + " 张票");
            x--;
        }
    }
}
```



```java
public class ThreadDemo {

    public static void main(String[] args) throws Exception {
        TicketDemo ticket = new TicketDemo();

        Thread thread1_1 = new Thread(ticket, "1号窗口 ");
        Thread thread1_2 = new Thread(ticket, "2号窗口 ");

        thread1_1.start();
        thread1_2.start();
    }
}
```



## 1.2 解决方案-synchronized

```java
/**
 * 同步锁的几种实现放方式
 * 区别: 
 *      Synchronized: 采用CPU悲观锁机制(JVM执行), 线程是独占的, 当很多线程进程锁时会引起CPU频繁切换而影响性能
 *      Lock: java写的乐观锁, 每次不加锁假设没有冲突去执行, 如果发生冲突则重试
 * @author 
 */
public class Test {
    public static void main(String[] args) {
        // 方式1: 同步代码块
        SynchronizedBlock block = new SynchronizedBlock();

        Thread thread1_1 = new Thread(block, "1号窗口");
        Thread thread1_2 = new Thread(block, "2号窗口");

        thread1_1.start();
        thread1_2.start();

        // 方式2: 同步方法
        SynchronizedMethod method = new SynchronizedMethod();

        Thread thread2_1 = new Thread(method, "1号窗口");
        Thread thread2_2 = new Thread(method, "2号窗口");

        thread2_1.start();
        thread2_2.start();

        // 方式3: 静态同步方法
        SynchronizedStaticMethod staticMethod = new SynchronizedStaticMethod();

        Thread thread3_1 = new Thread(staticMethod, "1号窗口");
        Thread thread3_2 = new Thread(staticMethod, "2号窗口");

        thread3_1.start();
        thread3_2.start();

        // 方式4: Lock锁
        LockBlock lockBlock = new LockBlock();

        Thread thread4_1 = new Thread(lockBlock, "1号窗口");
        Thread thread4_2 = new Thread(lockBlock, "2号窗口");

        thread4_1.start();
        thread4_2.start();

        // ==========================================================

        // 数据安全访问的几种方式
        DataSecurity data = new DataSecurity();

        Thread thread5_1 = new Thread(data, "thread 1");
        Thread thread5_2 = new Thread(data, "thread 2");

        thread5_1.start();
        thread5_2.start();
    }
}
```

```java
/**
 * 同步代码块
 * @author Luzhuo
 */
public class SynchronizedBlock implements Runnable{
    private static int x = 100; // 票的数量
    private Object obj = new Object();

    @Override
    public void run() {
        while (true) {
            syncBlock();
        }
    }

    /**
     * 方式1: 同步代码块, 锁对象:任意对象
     */
    public void syncBlock() {
        // synchronized代码同步锁
        synchronized (obj) { // 锁对象是new Object(); 
            if (x > 0) {
                try {
                    // public static void sleep(long millis); // 以指定毫秒数内暂停线程
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在出售第 " + (x--) + " 张票");
            }
        }
    }
}
```

```java
/**
 * 同步方法
 * @author Luzhuo
 */
public class SynchronizedMethod implements Runnable{
    private static int x = 100; // 票的数量

    @Override
    public void run() {
        while(true){
            syncMethod();
        }
    }

    /**
     * 方式2: 同步方法: 锁对象:this
     */
    private synchronized void syncMethod() {  //锁对象是 this
        if (x > 0) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "正在出售第 " + (x--) + " 张票");
        }
    }
}
```

```java
/**
 * 静态同步方法
 * @author Luzhuo
 *
 */
public class SynchronizedStaticMethod implements Runnable{
    private static int x = 100; // 票的数量

    @Override
    public void run() {
        while(true){
            syncStaticMethod();
        }
    }

    /**
     * 方式3: 静态同步方法: 锁对象: 类.class 字节码文件对象
     */
    private static synchronized void syncStaticMethod(){ //锁对象是 Ticket.class
        if (x > 0) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "正在出售第 " + (x--) + " 张票");
        }
    }
}
```

锁对象的区别：

```
同步代码块：添加锁的时候，锁对象可以是任意的对象，但是要保证多个线程间使用的是统一把锁
方法上：当前的锁对象是this(对象本身)
静态方法：类.class字节码文件对象
```





## 1.3 解决方案-Lock

```java
public class LockBlock implements Runnable{

    private int x = 100; // 票的数量
    private final Lock lock = new ReentrantLock();



    @Override
    public void run() {
        while (true) {
            lockBlock();
        }
    }


    public void lockBlock() {
        try{
            lock.lock();
            if (x > 0) {
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在出售第 " + x + " 张票");
                x--;
            }
        }finally {
            lock.unlock();
        }
    }
}
```

```java
public class Lockemo {
    public static void main(String[] args) {
        // Lock锁
        LockBlock lockBlock = new LockBlock();

        new Thread(lockBlock, "1号窗口").start();
        new Thread(lockBlock, "2号窗口").start();
    }
}
```

优点:

```
1. 相比Synchronized更加的灵活
2. 实现非阻塞锁
3. 实现超时锁
```

Lock底层的实现机制:

```
volatile+Cas算法
volatile作用：保证共享变量在多个线程间的可见性；不能保证共享变量的原子性操作。
Cas算法作用：保证写操作的原子性。
```



## 1.4 synchronized 与 Lock 区别

1). 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；

2). synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；

3). synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；

4). 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；

5). synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）

6). Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。





# 2. 死锁

条件

```
1.两个线程，都要获得2把锁
2.线程1持有锁A，想要获得锁B
3.线程2持有锁B，想要获得锁A

结果：2个线程同时持有对象想要获得的锁，并且互不相让。
```

解决方案：重启。

避免：同一个线程尽量不要获得2个锁。

```java
/**
 * 死锁的案例
 * 死锁的产生: 线程1拿着objA的锁去获取objB的锁, 线程2拿着objB的锁去获取objA的锁, 两者互不相让就产生了死锁
 * @author Luzhuo
 */
public class DeadLock{
    public static void main(String[] args) {
        DeadLock.DieLock d1 = new DeadLock.DieLock(true);
        DeadLock.DieLock d2 = new DeadLock.DieLock(false);
        
        d1.start();
        d2.start();
    }

    public static class DieLock extends Thread{
        private boolean flag;

        public DieLock(boolean flag){
            this.flag = flag;
        }

        public void run() {
            if(flag){
                while(true){
                    synchronized (Mylock.objA) {
                        System.out.println("if objA");
                        synchronized (Mylock.objB) {
                            System.out.println("if objB");
                        }
                    }
                }
            }else{
                while(true){
                    synchronized (Mylock.objB) {
                        System.out.println("else objB");
                        synchronized (Mylock.objA) {
                            System.out.println("else objA");
                        }
                    }
                }
            }
            // 执行结果:
            // if objA -> if objA -> if objA -> else objB -> 死锁
            // else objB -> else objB -> else objB -> if objA -> 死锁
            // if objA -> else objB -> 死锁
        }
    }

    public static class Mylock {
        public static final Object objA = new Object();
        public static final Object objB = new Object();
    }
}
```



# 3. 线程的等待唤醒机制

等待唤醒机制可以实现不同线程间的通信（数据交互）。

```
1. 多个线程共享同一把锁
2. 线程等待的方法锁对象.wait();
3. 线程唤醒的方法所对象.notify();
4. notify和notifyAll，前者是随机唤醒一个线程，后者是唤醒当前锁上的所有线程
```



## 3.1 Synchronized

```
锁对象.wait();	//等待
锁对象.notify();	//随机唤醒一个线程
锁对象.notifyAll()	//唤醒所有线程
```

```java
/**
 * 多线程的等待唤醒机制
 * wait: 当前线程等待,会释放锁; notify/notifyAll: 唤醒其他线程
 * @author Luzhuo
 */
public class WaitDemo {
    public static void main(String[] args) {
        Bean bean = new Bean();

        SetThread st = new SetThread(bean);
        GetThread gt = new GetThread(bean);
        Thread t1 = new Thread(st, "setData");
        Thread t2 = new Thread(gt, "getData");

        t1.start();
        t2.start();
    }

    /**
     * Bean
     * @author Luzhuo
     */
    public static class Bean {
        public int number = 0;
        public boolean flag = false;
    }

    public static class SetThread implements Runnable {
        private Bean mBean;
        private int count = 0;

        public SetThread(Bean bean) {
            this.mBean = bean;
        }

        @Override
        public void run() {
            while (true) {
                synchronized (mBean) {
                    try{
                        Thread.sleep(10);

                        if (mBean.flag) { // bean = true 则等待
                            // public final void wait(); // 当前线程等待
                            mBean.wait(); // wait和notify必须在同步代码块中使用, 因为在执行这两个方法之前要先获得锁
                        }

                        // 设置值
                        mBean.number = count;
                        System.out.println(Thread.currentThread().getName() + ": " + count);
                        count++;

                        mBean.flag = true;
                        // public final void notify(); // 唤醒对象监视器上等待的单个线程
                        mBean.notify(); // 唤醒一个等待该锁的线程, 然后继续执行完锁定区, 再释放锁

                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    public static class GetThread implements Runnable{
        private Bean mBean;

        public GetThread(Bean bean){
            this.mBean = bean;
        }

        @Override
        public void run(){
            while(true){
                synchronized (mBean) {
                    try{
                        Thread.sleep(10);

                        if(!mBean.flag) { // flag = false
                            mBean.wait(); // 等待会释放锁对象
                        }

                        System.out.println(Thread.currentThread().getName() + ": " + mBean.number);
                        mBean.flag = false;
                        mBean.notify();

                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```



wait 与 sleep区别 : 

1). wait 会释放锁 , sleep 不会释放锁 ;

2). wait 需要被程序通过notify / notifyAll 唤醒, 而 sleep 时间到达之后, 自己醒来 ;

3). wait 需要依赖于锁 , 而 sleep 在任何地方都可以 ;







# 4. volatile关键字

## 4.1 看程序说结果

```java
public class VolatileThread extends Thread { 
	// 定义成员变量
    private boolean flag = false ;
    public boolean isFlag() { 
    	return flag;
    }
    
    @Override
    public void run() {
        try {
        Thread.sleep(1000);
        } catch (InterruptedException e) {
        e.printStackTrace();
        }
        // 将flag的值更改为true
        this.flag = true ;
        System.out.println("flag=" + flag);
    }
}
```



```java
public class VolatileThreadDemo {
    // 测试类
    public static void main(String[] args) {
        // 创建VolatileThread线程对象
        VolatileThread volatileThread = new VolatileThread() ;
        volatileThread.start();
        // main方法
        while(true) {
            if(volatileThread.isFlag()) {
            	System.out.println("执行了======");
            }
        }
    }
}
```



## 4.2 JMM

概述：JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。
所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。

![1572584091780](assets/1572584091780.png) 



## 4.3 问题分析

![1572584153923](assets/1572584153923.png) 



1). VolatileThread线程从主内存读取到数据放入其对应的工作内存

2). 将flag的值更改为true，但是这个时候flag的值还没有写会主内存

3). 此时main方法读取到了flag的值为false

4). 当 VolatileThread 线程将flag的值写回去后，但是main函数里面的while(true)调用的是系统比较底层的代码，速度快，快到没有时间再去读取主存中的值，所以while(true)读取到的值一直是false。(如果有一个时刻main线程从主内存中读取到了主内存中flag的最新值，那么if语句就可以执行，main线程何时从主内存中读取最新的值，我们无法控制)



## 4.4 问题处理

```java
public class VolatileThreadDemo {
    // 测试类
    public static void main(String[] args) {
        // 创建VolatileThread线程对象
        VolatileThread volatileThread = new VolatileThread() ;
        volatileThread.start();
        
        // main方法
        while(true) {
            synchronized (volatileThread) {
                if(volatileThread.isFlag()) {
                    System.out.println("执行了======");
                }
            }
        try {
            	Thread.sleep(100);
            } catch (InterruptedException e) {
            	e.printStackTrace();
            }
        }
    }
}
```



某一个线程进入synchronized代码块前后，执行过程入如下：

1). 线程获得锁
2). 清空工作内存
3). 从主内存拷贝共享变量最新的值到工作内存成为副本
4). 执行代码
5). 将修改后的副本的值刷新回主内存中
6). 线程释放锁



## 4.5 volatile关键字

```java
private volatile boolean flag ; 
```

![1572584398719](assets/1572584398719.png) 

1). VolatileThread 线程从主内存读取到数据放入其对应的工作内存

2). 将flag的值更改为true，但是这个时候flag的值还没有写会主内存

3). 此时main方法读取到了flag的值为false

4). 当VolatileThread线程将flag的值写回去后，失效其他线程对此变量副本

5). 再次对flag进行操作的时候线程会从主内存读取最新的值，放入到工作内存中



总结： volatile保证不同线程对共享变量操作的**可见性**，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。但是volatile不保证原子性 。



## 4.6 volatile与synchronized

1). volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);
2). synchronized是一种排他（互斥）的机制，synchronized修饰的同步代码块，无法被中断可以保证原子性，也可以间接的保证可见性。





# 5. 原子性

## 5.1 概述

概述：所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。

比如：从张三的账户给李四的账户转1000元，这个动作将包含两个基本的操作：从张三的账户扣除1000元，给李四的账户增加1000元。这两个操作必须符合原子性的要求，要么都成功要么都失败 。



## 5.2 看程序说结果

```java
public class DataSecurity implements Runnable{

    @Override
    public void run() {
        int number = Integer.MAX_VALUE;
		
        while(number > 0){
            try {
                Thread.sleep(5);
                number = getNum1(); // 原始方式
                System.out.println(Thread.currentThread().getName() + ": " + number);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    private static int num1 = 100;
    public int getNum1(){
        return num1--;
    }
}    
```



```java
public class SecurityDemo {
    public static void main(String[] args) {
        // 数据安全访问的几种方式
        DataSecurity data = new DataSecurity();

        Thread thread5_1 = new Thread(data, "thread 1");
        Thread thread5_2 = new Thread(data, "thread 2");
        Thread thread5_3 = new Thread(data, "thread 3");
        Thread thread5_4 = new Thread(data, "thread 4");
        Thread thread5_5 = new Thread(data, "thread 5");

        thread5_1.start();
        thread5_2.start();
        thread5_3.start();
        thread5_4.start();
        thread5_5.start();
    }
}
```





## 5.3 问题原理说明

以上问题主要是发生在count++操作上：
count++操作包含3个步骤：
1). 从主内存中读取数据到工作内存
2). 对工作内存中的数据进行++操作
3). 将工作内存中的数据写回到主内存
count++操作不是一个原子性操作，也就是说在某一个时刻对某一个操作的执行，有可能被其他的线程打断。









![1572584700100](assets/1572584700100.png) 



1）假设此时x的值是 100，线程A需要对改变量进行自增1的操作，首先它需要从主内存中读取变量x的值。由于CPU的切换关系，此时CPU的执行权被切换到了B线程。A线程就处于就绪状态，B线程处于运行状态
2）线程B也需要从主内存中读取x变量的值,由于线程A没有对x值做任何修改因此此时B读取到的数据还是100
3）线程B工作内存中x执行了+1操作，但是未刷新之主内存中

4）此时CPU的执行权切换到了A线程上，由于此时线程B没有将工作内存中的数据刷新到主内存，因此A线程工作内存中的变量值还是100，没有失效。A线程对工作内存中的数据进行了+1操作
5）线程B将101写入到主内存
6）线程A将101写入到主内存虽然计算了2次，但是只对A进行了1次修改。



## 5.4 volatile原子性测试

```
// 定义一个int类型的变量
private volatile int count = 100 ;
```

小结：在多线程环境下，volatile关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性（在多线程环境下volatile修饰的变量也是线程不安全的）。在多线程环境下，要保证数据的安全性，我们还需要使用锁机制。



## 5.5 volatile的使用场景

1). 开关控制
​    利用可见性特点，控制某一段代码执行或者关闭(比如今天课程的第一个案例)。

```
// 定义一个int类型的变量
private volatile int count = 0 ;
```

2). 多个线程操作共享变量，但是是有一个线程对其进行写操作，其他的线程都是读



## 5.6 问题解决

### 5.6.1 使用锁机制

我们可以给count++操作添加锁，那么count++操作就是临界区的代码，临界区只能有一个线程去执行，所以count++就变成了原子操作。

```java
public class VolatileAtomicThread implements Runnable {
    // 定义一个int类型的变量
    private volatile int count = 0 ;
    private static final Object obj = new Object();
    
    @Override
    public void run() {
        // 对该变量进行++操作，100次
        for(int x = 0 ; x < 100 ; x++) {
            synchronized (obj) {
                count++ ;
                System.out.println("count =========>>>> " + count);
            }
        }
    }
}
```



### 5.6.2 原子类

概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。

#### AtomicInteger

原子型Integer，可以实现原子更新操作

```java
public AtomicInteger()： 初始化一个默认值为0的原子型Integer

public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer

int get(): 获取值

int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。

int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。

int addAndGet(int data): 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。

int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值
```

查看AtomicInteger原子操作方法；

```java
public static void main(String[] args) {
    // public AtomicInteger()： 初始化一个默认值为0的原子型Integer
    // public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer
    
    // int get(): 获取值
    // int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。
    // int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。
    // int addAndGet(int data): 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。
    // int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。
    AtomicInteger atomicInteger = new AtomicInteger(5);
    System.out.println(atomicInteger.get());
    System.out.println(atomicInteger.getAndIncrement());
    System.out.println(atomicInteger.get());
    System.out.println(atomicInteger.incrementAndGet());
    System.out.println(atomicInteger.addAndGet(8));
    System.out.println(atomicInteger.getAndSet(20));
    System.out.println(atomicInteger.get());
}
```



#### 案例改造

```java
package cn.itcast.atomic;
import java.util.concurrent.atomic.AtomicInteger;

public class DataSecurity implements Runnable{
    @Override
    public void run() {
        int number = Integer.MAX_VALUE;

        while(number > 0){
            try {
                Thread.sleep(5);
                number = getNum3(); // 原始方式
                System.out.println(Thread.currentThread().getName() + ": " + number);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
	
    private AtomicInteger num3 = new AtomicInteger(100);
    public int getNum3(){
        return num3.getAndDecrement();
    }
	
}
```











